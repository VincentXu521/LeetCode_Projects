Step1: get issue via url: https://api.github.com/repos/grandyang/leetcode/issues/419 
 title:[LeetCode] 419. Battleships in a Board 
 body:  
 Â 

Given an 2D board, count how many different battleships are in it. The battleships are represented withÂ `'X'`s, empty slots are represented withÂ `'.'`s. You may assume the following rules:

  * You receive a valid board, made of only battleships or empty slots.
  * Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shapeÂ `1xN`Â (1 row, N columns) orÂ `Nx1`Â (N rows, 1 column), where N can be of any size.
  * At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.



Example:
    
    
    X..X
    ...X
    ...X
    

In the above board there are 2 battleships.

Invalid Example:
    
    
    ...X
    XXXX
    ...X
    

This is not a valid board - as battleships will always have a cell separating between them.

Your algorithm should not modify the value of the board.

Â 

è¿™é“é¢˜å¥½åƒä¹‹å‰åœ¨åœ°é‡Œé¢è§è¿‡ï¼Œå¿˜äº†æ˜¯å“ªå®¶å…¬å¸çš„é¢è¯•é¢˜äº†ï¼Œç°åœ¨è¢«LeetCodeæ”¶å½•äº†ï¼Œæ„Ÿè§‰ç°åœ¨LeetCodeæ›´æ–°è¶Šæ¥è¶Šå¿«äº†ï¼Œæ„Ÿè§‰è¦æˆä¸ºç¬¬ä¸€å¤§é¢˜åº“äº†ï¼Œèµä¸€ä¸ªğŸ‘ã€‚è¿™é“é¢˜è®©æˆ‘ä»¬æ±‚æˆ˜èˆ°çš„ä¸ªæ•°ï¼Œæ‰€è°“çš„æˆ˜èˆ°å°±æ˜¯åªèƒ½æ˜¯ä¸€è¡Œæˆ–è€…ä¸€åˆ—ï¼Œä¸èƒ½æœ‰æ‹å¼¯ã€‚è¿™é“é¢˜é™ä½äº†éš¾åº¦çš„åšæ³•æ˜¯é™å®šäº†ä¸ä¼šæœ‰ç›¸é‚»çš„ä¸¤ä¸ªæˆ˜èˆ°çš„å­˜åœ¨ï¼Œæœ‰äº†è¿™ä¸€ç‚¹é™åˆ¶ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦éå†ä¸€æ¬¡äºŒç»´æ•°ç»„å°±è¡Œäº†ï¼Œåªè¦æ‰¾å‡ºæˆ˜èˆ°çš„èµ·å§‹ç‚¹ã€‚æ‰€è°“çš„æˆ˜èˆ°èµ·å§‹ç‚¹ï¼Œå°±æ˜¯ä¸ºXçš„ç‚¹ï¼Œè€Œä¸”è¯¥ç‚¹çš„ä¸Šæ–¹å’Œå·¦è¾¹çš„ç‚¹ä¸èƒ½ä¸ºXï¼Œæ‰€ä»¥æˆ‘ä»¬åªè¦æ‰¾å‡ºæ‰€æœ‰æ»¡è¶³è¿™ä¸ªæ¡ä»¶çš„ç‚¹å³å¯ï¼Œå‚è§ä»£ç å¦‚ä¸‹ï¼š

Â 

è§£æ³•ä¸€ï¼š
    
    
    class Solution {
    public:
        int countBattleships(vector<vector<char>>& board) {
            if (board.empty() || board[0].empty()) return 0;
            int res = 0, m = board.size(), n = board[0].size();
            for (int i = 0; i < m; ++i) {
                for (int j = 0; j < n; ++j) {
                    if (board[i][j] == '.' || (i > 0 && board[i - 1][j] == 'X') || (j > 0 && board[i][j - 1] == 'X')) continue;
                    ++res;
                }
            }
            return res;
        }
    };

Â 

ç„¶è€Œæˆ‘è‡ªå·±åœ¨åšçš„æ—¶å€™å¹¶æ²¡æœ‰æ³¨æ„åˆ°é¢˜ç›®ä¸­é™åˆ¶äº†ä¸¤è‰˜æˆ˜èˆ°ä¸èƒ½ç›¸é‚»çš„æƒ…å†µï¼Œæˆ‘åŠ ä¸Šäº†å¤„ç†æ–¹æ³•ï¼Œé¦–å…ˆæˆ‘ç®—å‡ºæ¥äº†æ‰€æœ‰è¿ç»­Xçš„åŒºåŸŸçš„ä¸ªæ•°ï¼Œæ–¹æ³•è·Ÿä¹‹å‰é‚£é“[Number of Islands](http://www.cnblogs.com/grandyang/p/4402656.html)ä¸€æ ·ï¼Œç¨æœ‰ä¸åŒçš„æ˜¯ï¼Œæˆ‘åˆ†åˆ«è®°å½•ä¸‹æ¥æ¯ä¸€ä¸ªè¿ç»­åŒºåŸŸçš„iå’Œjï¼ŒæŠŠæ‰€æœ‰çš„ç‚¹çš„æ¨ªçºµåæ ‡åˆ†åˆ«æˆ–äº†èµ·æ¥ï¼Œè¿™æ ·åšçš„å¥½å¤„æ˜¯å¦‚æœæ˜¯åœ¨ä¸€æ¡ç›´çº¿ä¸Šçš„æˆ˜èˆ°ï¼Œé‚£ä¹ˆæ‰€æœ‰ç‚¹è‚¯å®šæ˜¯è¦ä¹ˆæ¨ªåæ ‡éƒ½ç›¸åŒï¼Œè¦ä¹ˆçºµåæ ‡éƒ½ç›¸åŒï¼Œæ‰€ä»¥æœ€åæˆ‘ä»¬æ£€æµ‹å¦‚æœæ¨ªçºµåæ ‡çš„ç´¯ç§¯æˆ–éƒ½è·Ÿä¹‹å‰çš„iå’Œjä¸åŒçš„è¯ï¼Œé‚£ä¹ˆä¸€å®šä¸æ˜¯é¢˜ç›®ä¸­å®šä¹‰çš„æˆ˜èˆ°ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±ä¸ç´¯åŠ ç»“æœresï¼Œå‚è§ä»£ç å¦‚ä¸‹ï¼š

Â 

è§£æ³•äºŒï¼š
    
    
    class Solution {
    public:
        int countBattleships(vector<vector<char>>& board) {
            if (board.empty() || board[0].empty()) return 0;
            int m = board.size(), n = board[0].size(), res = 0;
            vector<vector<bool>> visited(m, vector<bool>(n, false));
            for (int i = 0; i < m; ++i) {
                for (int j = 0; j < n; ++j) {
                    if (board[i][j] == 'X' && !visited[i][j]) {
                        int vertical = 0, horizontal = 0;
                        dfs(board, visited, vertical, horizontal, i, j);
                        if (vertical == i || horizontal == j) ++res;
                    }
                }
            }
            return res;
        }
        void dfs(vector<vector<char>>& board, vector<vector<bool>>& visited, int& vertical, int& horizontal, int i, int j) {
            int m = board.size(), n = board[0].size();
            if (i < 0 || i >= m || j < 0 || j >= n || visited[i][j] || board[i][j] == '.') return;
            vertical |= i; horizontal |= j;
            visited[i][j] = true;
            dfs(board, visited, vertical, horizontal, i - 1, j);
            dfs(board, visited, vertical, horizontal, i + 1, j);
            dfs(board, visited, vertical, horizontal, i, j - 1);
            dfs(board, visited, vertical, horizontal, i, j + 1);
        }
    };

Â 

æ—¢ç„¶DFSèƒ½å®ç°ï¼Œé‚£ä¹ˆBFSå°±åº”è¯¥æ²¡å•¥é—®é¢˜ï¼Œè¿™é‡Œå®Œå…¨æŒ‰é¢˜ç›®çš„è¦æ±‚ï¼Œé»˜è®¤ä¸¤ä¸ªæˆ˜èˆ°ä¸ä¼šç›¸é‚»ï¼Œå¹¶æ²¡æœ‰æ·»åŠ è§£æ³•äºŒä¸­çš„è¿‡æ»¤æ¡ä»¶ï¼Œå‚è§ä»£ç å¦‚ä¸‹ï¼š

Â 

è§£æ³•ä¸‰ï¼š
    
    
    class Solution {
    public:
        int countBattleships(vector<vector<char>>& board) {
            if (board.empty() || board[0].empty()) return 0;
            int res = 0, m = board.size(), n = board[0].size();
            vector<vector<bool>> visited(m, vector<bool>(n, false));
            vector<vector<int>> dirs{{0,-1},{-1,0},{0,1},{1,0}};
            for (int i = 0; i < m; ++i) {
                for (int j = 0; j < n; ++j) {
                    if (board[i][j] == 'X' && !visited[i][j]) {
                        ++res;
                        queue<pair<int, int>> q;
                        q.push({i, j});
                        while (!q.empty()) {
                            auto t = q.front(); q.pop();
                            visited[t.first][t.second] = true;
                            for (auto dir : dirs) {
                                int x = t.first + dir[0], y = t.second + dir[1];
                                if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y] || board[x][y] == '.') continue;
                                q.push({x, y});
                            }
                        }
                    }
                }
            }
            return res;
        }
    };

Â 

å‚è€ƒèµ„æ–™ï¼š

<https://discuss.leetcode.com/topic/62970/simple-java-solution>

<https://discuss.leetcode.com/topic/62997/dfs-bfs-flood-fill-algorithm-with-c/2>

Â 

[LeetCode All in One é¢˜ç›®è®²è§£æ±‡æ€»(æŒç»­æ›´æ–°ä¸­...)](http://www.cnblogs.com/grandyang/p/4606334.html)
